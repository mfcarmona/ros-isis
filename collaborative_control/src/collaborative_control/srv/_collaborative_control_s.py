"""autogenerated by genmsg_py from collaborative_control_sRequest.msg. Do not edit."""
import roslib.message
import struct

import geometry_msgs.msg
import efficiency.msg

class collaborative_control_sRequest(roslib.message.Message):
  _md5sum = "b8ee8ccde4e2ffbfb5bf573b14fdaa15"
  _type = "collaborative_control/collaborative_control_sRequest"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """float32 weigthA
geometry_msgs/Point comandA
efficiency/Efficiency_m etaA
float32 weigthB
geometry_msgs/Point comandB
efficiency/Efficiency_m etaB

================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z

================================================================================
MSG: efficiency/Efficiency_m
float32 Global
float32 Safety
float32 Directness
float32 Smoothness


"""
  __slots__ = ['weigthA','comandA','etaA','weigthB','comandB','etaB']
  _slot_types = ['float32','geometry_msgs/Point','efficiency/Efficiency_m','float32','geometry_msgs/Point','efficiency/Efficiency_m']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       weigthA,comandA,etaA,weigthB,comandB,etaB
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(collaborative_control_sRequest, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.weigthA is None:
        self.weigthA = 0.
      if self.comandA is None:
        self.comandA = geometry_msgs.msg.Point()
      if self.etaA is None:
        self.etaA = efficiency.msg.Efficiency_m()
      if self.weigthB is None:
        self.weigthB = 0.
      if self.comandB is None:
        self.comandB = geometry_msgs.msg.Point()
      if self.etaB is None:
        self.etaB = efficiency.msg.Efficiency_m()
    else:
      self.weigthA = 0.
      self.comandA = geometry_msgs.msg.Point()
      self.etaA = efficiency.msg.Efficiency_m()
      self.weigthB = 0.
      self.comandB = geometry_msgs.msg.Point()
      self.etaB = efficiency.msg.Efficiency_m()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      _x = self
      buff.write(_struct_f3d5f3d4f.pack(_x.weigthA, _x.comandA.x, _x.comandA.y, _x.comandA.z, _x.etaA.Global, _x.etaA.Safety, _x.etaA.Directness, _x.etaA.Smoothness, _x.weigthB, _x.comandB.x, _x.comandB.y, _x.comandB.z, _x.etaB.Global, _x.etaB.Safety, _x.etaB.Directness, _x.etaB.Smoothness))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      if self.comandA is None:
        self.comandA = geometry_msgs.msg.Point()
      if self.etaA is None:
        self.etaA = efficiency.msg.Efficiency_m()
      if self.comandB is None:
        self.comandB = geometry_msgs.msg.Point()
      if self.etaB is None:
        self.etaB = efficiency.msg.Efficiency_m()
      end = 0
      _x = self
      start = end
      end += 88
      (_x.weigthA, _x.comandA.x, _x.comandA.y, _x.comandA.z, _x.etaA.Global, _x.etaA.Safety, _x.etaA.Directness, _x.etaA.Smoothness, _x.weigthB, _x.comandB.x, _x.comandB.y, _x.comandB.z, _x.etaB.Global, _x.etaB.Safety, _x.etaB.Directness, _x.etaB.Smoothness,) = _struct_f3d5f3d4f.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      _x = self
      buff.write(_struct_f3d5f3d4f.pack(_x.weigthA, _x.comandA.x, _x.comandA.y, _x.comandA.z, _x.etaA.Global, _x.etaA.Safety, _x.etaA.Directness, _x.etaA.Smoothness, _x.weigthB, _x.comandB.x, _x.comandB.y, _x.comandB.z, _x.etaB.Global, _x.etaB.Safety, _x.etaB.Directness, _x.etaB.Smoothness))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      if self.comandA is None:
        self.comandA = geometry_msgs.msg.Point()
      if self.etaA is None:
        self.etaA = efficiency.msg.Efficiency_m()
      if self.comandB is None:
        self.comandB = geometry_msgs.msg.Point()
      if self.etaB is None:
        self.etaB = efficiency.msg.Efficiency_m()
      end = 0
      _x = self
      start = end
      end += 88
      (_x.weigthA, _x.comandA.x, _x.comandA.y, _x.comandA.z, _x.etaA.Global, _x.etaA.Safety, _x.etaA.Directness, _x.etaA.Smoothness, _x.weigthB, _x.comandB.x, _x.comandB.y, _x.comandB.z, _x.etaB.Global, _x.etaB.Safety, _x.etaB.Directness, _x.etaB.Smoothness,) = _struct_f3d5f3d4f.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

_struct_I = roslib.message.struct_I
_struct_f3d5f3d4f = struct.Struct("<f3d5f3d4f")
"""autogenerated by genmsg_py from collaborative_control_sResponse.msg. Do not edit."""
import roslib.message
import struct

import geometry_msgs.msg

class collaborative_control_sResponse(roslib.message.Message):
  _md5sum = "0f200156ab0eb42d7915c776a70ef7bc"
  _type = "collaborative_control/collaborative_control_sResponse"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """geometry_msgs/Point comandC



================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z

"""
  __slots__ = ['comandC']
  _slot_types = ['geometry_msgs/Point']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       comandC
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(collaborative_control_sResponse, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.comandC is None:
        self.comandC = geometry_msgs.msg.Point()
    else:
      self.comandC = geometry_msgs.msg.Point()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      _x = self
      buff.write(_struct_3d.pack(_x.comandC.x, _x.comandC.y, _x.comandC.z))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      if self.comandC is None:
        self.comandC = geometry_msgs.msg.Point()
      end = 0
      _x = self
      start = end
      end += 24
      (_x.comandC.x, _x.comandC.y, _x.comandC.z,) = _struct_3d.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      _x = self
      buff.write(_struct_3d.pack(_x.comandC.x, _x.comandC.y, _x.comandC.z))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      if self.comandC is None:
        self.comandC = geometry_msgs.msg.Point()
      end = 0
      _x = self
      start = end
      end += 24
      (_x.comandC.x, _x.comandC.y, _x.comandC.z,) = _struct_3d.unpack(str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

_struct_I = roslib.message.struct_I
_struct_3d = struct.Struct("<3d")
class collaborative_control_s(roslib.message.ServiceDefinition):
  _type          = 'collaborative_control/collaborative_control_s'
  _md5sum = '6f29b80ef1ae1821153e3c4550e43179'
  _request_class  = collaborative_control_sRequest
  _response_class = collaborative_control_sResponse
